#!/usr/bin/lua
require('libusb');

function table.val_to_str ( v )
   if "string" == type( v ) then
      v = string.gsub( v, "\n", "\\n" )
      if string.match( string.gsub(v,"[^'\"]",""), '^"+$' ) then
	 return "'" .. v .. "'"
      end
      return '"' .. string.gsub(v,'"', '\\"' ) .. '"'
   else
      return "table" == type( v ) and table.tostring( v ) or
	 tostring( v )
   end
end

function table.key_to_str ( k )
   if "string" == type( k ) and string.match( k, "^[_%a][_%a%d]*$" ) then
      return k
   else
      return "[" .. table.val_to_str( k ) .. "]"
   end
end

function table.tostring( tbl )
   local result, done = {}, {}
   for k, v in ipairs( tbl ) do
      table.insert( result, table.val_to_str( v ) )
      done[ k ] = true
   end
   for k, v in pairs( tbl ) do
      if not done[ k ] then
	 table.insert( result,
		       table.key_to_str( k ) .. "=" .. table.val_to_str( v ) )
      end
   end
   return "{" .. table.concat( result, "," ) .. "}"
end


-- Simply dumps a table, and is pretty much only a wrapper
-- for a loop. It is useful however, because you can specify
-- a specific type, and only values of that type will be listed
local function dump(x,y)
   if type(x) ~= "table" then
      error("expected table and string, but got " .. type(x) .. " and " ..type(y), 2);
   end
   
   for k,v in pairs(x) do
      -- if a type is specified, check to see
      -- if current value is of right type.
      if y ~= nil then
	 if type(v) == y then
	    print(k, "\t", v);
	 end
      else
	 print(k, "\t", v)
      end
   end
end

-- Once again, just another wrapper. Still useful.
function globaldump(type)
   print("Current Lua Memory Usage: "..collectgarbage("count").." Kilobytes\n");
   dump(_G, type);
end


lunartool = {};

function lunartool.find_devices(vid, pid)
   ret = {};
   local buses=libusb.get_busses()
   local last_device
   for busname, bus in pairs(buses) do
      local devices=libusb.get_devices(bus)
      for devname, device in pairs(devices) do
	 local descriptor=libusb.device_descriptor(device)
	 if ((vid == 0) or (descriptor.idVendor == vid) ) then
	    if ((pid == 0) or (descriptor.idProduct == pid)) then
	       table.insert(ret, {
			       descriptor = descriptor,
			       dev = device,
			       bus = bus
				 })
	    end
	 end
	 --table.insert(ret, { 
	 -- print ("Bus: " .. dirname, "Device: " .. filename, 
	 --	"ID: "..string.format("%04x:%04x", descriptor.idVendor,descriptor.idProduct))-- , "desc:", descriptor.iProduct, s or err)
	 last_device=device		
      end     
   end
   return ret
end


function lunartool.string_filter(devs, v, p, s)
   matches = {};
   for num,device in pairs(devs) do
      --print(table.tostring(device));
      hndl = libusb.open(device.dev);
      if (nil == hndl) then
	 print("Couldn't open dev, skipping")
      else
	 -- print(device.descriptor.iVendor);
	 vendor,err = libusb.get_string_simple(hndl,device.descriptor.iManufacturer);
	 if (err) then vendor = "?" end
	 product,err = libusb.get_string_simple(hndl,device.descriptor.iProduct);
	 if (err) then product = "?" end
	 serial,err = libusb.get_string_simple(hndl,device.descriptor.iSerialNumber);
	 if (err) then serial = "?" end
	 if ((nil == v) or (v == vendor)) then
	    if ((nil == p) or (p == product)) then
	       if ((nil == s) or (s == serial)) then
		  table.insert(matches, {
				  device = device,
				  vendor = vendor,
				  product = product,
				  serial = serial,
				  hndl = hndl
					})
	       else
		  libusb.close(hndl); -- clean up
	       end
	    end
	 end
      end
   end
   return matches;
end


-- getopt, POSIX style command line argument parser
-- param arg contains the command line arguments in a standard table.
-- param options is a string with the letters that expect string values.
-- returns a table where associated keys are true, nil, or a string value.
-- The following example styles are supported
--   -a one  ==> opts["a"]=="one"
--   -bone   ==> opts["b"]=="one"
--   -c      ==> opts["c"]==true
--   --c=one ==> opts["c"]=="one"
--   -cdaone ==> opts["c"]==true opts["d"]==true opts["a"]=="one"
-- note POSIX demands the parser ends at the first non option
--      this behavior isn't implemented.

function lunartool.getopt( arg, options )
   local tab = {}
   for k, v in ipairs(arg) do
      if string.sub( v, 1, 2) == "--" then
	 local x = string.find( v, "=", 1, true )
	 if x then tab[ string.sub( v, 3, x-1 ) ] = string.sub( v, x+1 )
	 else      tab[ string.sub( v, 3 ) ] = true
	 end
      elseif string.sub( v, 1, 1 ) == "-" then
	 local y = 2
	 local l = string.len(v)
	 local jopt
	 while ( y <= l ) do
	    jopt = string.sub( v, y, y )
	    if string.find( options, jopt, 1, true ) then
	       if y < l then
		  tab[ jopt ] = string.sub( v, y+1 )
		  y = l
	       else
		  tab[ jopt ] = arg[ k + 1 ]
	       end
	    else
	       tab[ jopt ] = true
	    end
	    y = y + 1
	 end
      end
   end
   return tab
end

--
-- Pure Lua version of basename.
--
lunartool.basename = function(path)
   local i = string.len(path)

   while string.sub(path, i, i) == "/" and i > 0 do
      path = string.sub(path, 1, i - 1)
      i = i - 1
   end
   while i > 0 do
      if string.sub(path, i, i) == "/" then
	 break
      end
      i = i - 1
   end
   if i > 0 then
      path = string.sub(path, i + 1, -1)
   end
   if path == "" then
      path = "/"
   end

   return path
end

function table.contains(table, element)
  for _, value in pairs(table) do
    if value == element then
      return true
    end
  end
  return false
end

function lunartool.printusage(applet)
   print("Necromant's Lunartool :: " .. aname);
   print(config.description);
   print("--- USAGE ---");
   for n,v in pairs(config.usage) do
      print(v);
   end
end

function lunartool.listdevs(devs)
   print("--- Matching devices ---");
   if nil == devs then
      print("NONE")
   else
      for a,d in pairs(devs) do
	 print("ID: " .. a .. " Manufacturer: " .. d.vendor .. 
	       " Product: " .. d.product .. " Serial: " .. d.serial);
      end
   end
end


-- actual single-user stuff --
function lunartool.init()
   applet = lunartool.basename(arg[0]);
   applets = os.getenv("LUNARTOOL_APPLETS")
   if (nil == applets) then
      applets=/usr/share/lunartool
   end
   if (applet == 'lunartool') then
      print("Don't call me directly. Plz");
      os.exit(1);
   end
   aname = applet;
   applet = applets .. "/" .. applet .. ".lua";
   dofile(applet);
   lunartool.args = lunartool.getopt(arg, "d");
   tab = lunartool.args;
   if tab['help'] or tab['h'] then
      lunartool.printusage(aname);
      os.exit(1)
   end

   if nil ~= tab['vid'] then
      config.vid = tonumber(tab['vid']);
      print("Forced vid from commandline: " .. config.vid);
   end

   if nil ~= tab['pid'] then
      config.pid = tonumber(tab['pid']);
      print("Forced pid from commandline: " .. config.pid);
   end

   if nil ~= tab['vendor'] then
      config.vendor = tab['vendor'];
      print("Forced vendor from commandline: " .. config.vendor);
   end

   if nil ~= tab['product'] then
      config.product = tab['product'];
      print("Forced product from commandline: " .. config.product);
   end

   if nil ~= tab['serial'] then
      config.serial = tab['serial'];
      print("Forced serial from commandline: " .. config.serial);
   end

   devs = lunartool.find_devices(config.vid, config.pid);
   devs = lunartool.string_filter(devs, config.vendor, config.product, config.serial)

   if tab['list'] or tab['l'] then
      lunartool.listdevs(devs);
      os.exit(1)
   end

   offset=1
   -- Handle offsets and broadcasts
   if nil ~= tab['id'] then
      offset = tonumber(tab['id'])
   end
   
   if (tab['broadcast'] or tab['b']) then
      broadcast = true;
   end

   
   for i,device in pairs(devs) do
      if (broadcast or (i == offset)) then  
	 if nil ~= config.actions.start then
	    config.actions.start(i,device)
	 end
	 if not broadcast then
	    break;	
	 end
      end
   end
   
   -- Callbacks
   
   for j,t in pairs(tab) do
      for i,device in pairs(devs) do
	 if (broadcast or (i == offset)) then  
	    if nil ~= config.actions[j] then
	       config.actions[j](i,device,t)
	    end
	    if not broadcast then
	       break;	
	    end
	 end
      end
   end
   
   for i,device in pairs(devs) do
      if (broadcast or (i == offset)) then  
	     if nil ~= config.actions.finish then
		config.actions.finish(i,device)
	     end
	     if not broadcast then
		break;	
	     end
      end
   end

   os.exit(returncode);

   print(table.tostring());

   print(applet)
end

returncode=0
lunartool.init();




--Now, the actual applet loading logic

--devs = lunartool.find_devices(0x16c0, 0x05df);
--lubusb.control_msg(

--print(table.tostring(find_devices(0x16c0,0x05df)));

